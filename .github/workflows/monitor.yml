name: Monitor YouTube Channel

on:
  schedule:
    # Run at 8am and 8pm UTC
    - cron: '0 8,20 * * *'
  workflow_dispatch:
    # Allow manual trigger
    inputs:
      force_url:
        description: 'Force process a specific video URL (optional)'
        required: false
        type: string

env:
  WHISPER_MODEL: base
  GPT_MODEL: gpt-4o-mini

jobs:
  check-and-process:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Cache apt packages
        uses: awalsh128/cache-apt-pkgs-action@latest
        with:
          packages: ffmpeg
          version: 1.0

      - name: Cache Whisper model
        uses: actions/cache@v4
        with:
          path: ~/.cache/whisper
          key: whisper-${{ env.WHISPER_MODEL }}

      - name: Install Python dependencies
        run: |
          pip install --upgrade pip
          pip install -r requirements.txt

      - name: Check for new videos
        id: monitor
        if: ${{ !inputs.force_url }}
        env:
          YOUTUBE_CHANNEL_ID: ${{ secrets.YOUTUBE_CHANNEL_ID }}
        run: |
          set +e  # Don't exit on error
          python src/monitor.py 2>&1 | tee monitor_output.txt
          EXIT_CODE=${PIPESTATUS[0]}
          set -e

          if [ $EXIT_CODE -ne 0 ]; then
            echo "Monitor script failed with exit code $EXIT_CODE"
            exit $EXIT_CODE
          fi

          if grep -q "Found .* new video" monitor_output.txt; then
            echo "new_video=true" >> $GITHUB_OUTPUT
            VIDEO_URL=$(grep -oP 'https://www.youtube.com/watch\?v=\S+' monitor_output.txt | head -1)
            echo "video_url=${VIDEO_URL}" >> $GITHUB_OUTPUT
            VIDEO_ID=$(echo "$VIDEO_URL" | grep -oP 'v=\K[^&]+')
            echo "video_id=${VIDEO_ID}" >> $GITHUB_OUTPUT
          else
            echo "new_video=false" >> $GITHUB_OUTPUT
          fi

      - name: Set forced URL
        id: forced
        if: ${{ inputs.force_url }}
        run: |
          echo "new_video=true" >> $GITHUB_OUTPUT
          echo "video_url=${{ inputs.force_url }}" >> $GITHUB_OUTPUT

      - name: Get video metadata
        id: metadata
        if: steps.monitor.outputs.new_video == 'true' || steps.forced.outputs.new_video == 'true'
        run: |
          VIDEO_URL="${{ steps.monitor.outputs.video_url || steps.forced.outputs.video_url }}"
          echo "Getting metadata for: $VIDEO_URL"

          # Extract video ID from URL
          VIDEO_ID=$(echo "$VIDEO_URL" | grep -oP 'v=\K[^&]+')
          echo "Video ID: $VIDEO_ID"

          # Get title from YouTube oEmbed API (no auth required)
          OEMBED_URL="https://www.youtube.com/oembed?url=${VIDEO_URL}&format=json"
          echo "Fetching oEmbed: $OEMBED_URL"
          OEMBED_JSON=$(curl -s "$OEMBED_URL")
          echo "oEmbed response: $OEMBED_JSON"

          TITLE=$(echo "$OEMBED_JSON" | jq -r '.title')
          echo "Title: $TITLE"

          # Try to parse date from title (common formats: "Jan. 6, 2026", "January 6, 2026", "2026-01-06")
          # Extract date if present, otherwise no date prefix
          FORMATTED_DATE=""

          # Try "Mon. D, YYYY" or "Month D, YYYY" format
          if echo "$TITLE" | grep -qP '(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\.?\s+\d{1,2},?\s+\d{4}'; then
            DATE_STR=$(echo "$TITLE" | grep -oP '(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\.?\s+\d{1,2},?\s+\d{4}' | head -1)
            FORMATTED_DATE=$(date -d "$DATE_STR" +%Y-%m-%d 2>/dev/null || echo "")
          fi

          # Try "YYYY-MM-DD" format
          if [ -z "$FORMATTED_DATE" ] && echo "$TITLE" | grep -qP '\d{4}-\d{2}-\d{2}'; then
            FORMATTED_DATE=$(echo "$TITLE" | grep -oP '\d{4}-\d{2}-\d{2}' | head -1)
          fi

          if [ -n "$FORMATTED_DATE" ]; then
            echo "Parsed date: $FORMATTED_DATE"
          else
            echo "No date found in title"
          fi

          # Sanitize title for filename
          SAFE_TITLE=$(echo "$TITLE" | tr ' ' '_' | tr -cd '[:alnum:]_-' | cut -c1-100)

          # Fallback if title is empty
          if [ -z "$SAFE_TITLE" ]; then
            SAFE_TITLE="$VIDEO_ID"
          fi

          # Build filename with or without date
          if [ -n "$FORMATTED_DATE" ]; then
            FILENAME="sermon_${FORMATTED_DATE}_${SAFE_TITLE}"
          else
            FILENAME="sermon_${SAFE_TITLE}"
          fi

          echo "Filename: $FILENAME"
          echo "video_id=${VIDEO_ID}" >> $GITHUB_OUTPUT
          echo "filename=${FILENAME}" >> $GITHUB_OUTPUT

      - name: Download audio
        if: steps.monitor.outputs.new_video == 'true' || steps.forced.outputs.new_video == 'true'
        run: |
          VIDEO_URL="${{ steps.monitor.outputs.video_url || steps.forced.outputs.video_url }}"
          echo "Downloading: $VIDEO_URL"
          mkdir -p output
          yt-dlp -x --audio-format mp3 -o "output/audio.%(ext)s" "$VIDEO_URL"

      - name: Transcribe audio
        if: steps.monitor.outputs.new_video == 'true' || steps.forced.outputs.new_video == 'true'
        run: |
          echo "Transcribing with Whisper ($WHISPER_MODEL model)..."
          python src/transcribe.py output/audio.mp3 $WHISPER_MODEL

      - name: Segment sermon
        id: segment
        if: steps.monitor.outputs.new_video == 'true' || steps.forced.outputs.new_video == 'true'
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          echo "Segmenting with GPT ($GPT_MODEL)..."
          set +e  # Don't exit on error
          python src/segment.py audio_transcript.json $GPT_MODEL
          EXIT_CODE=$?
          set -e
          if [ $EXIT_CODE -eq 2 ]; then
            echo "No sermon found in video - skipping cleanup"
            echo "sermon_found=false" >> $GITHUB_OUTPUT
          elif [ $EXIT_CODE -ne 0 ]; then
            echo "Segmentation failed with exit code $EXIT_CODE"
            exit $EXIT_CODE
          else
            echo "sermon_found=true" >> $GITHUB_OUTPUT
          fi

      - name: Cleanup transcript
        if: (steps.monitor.outputs.new_video == 'true' || steps.forced.outputs.new_video == 'true') && steps.segment.outputs.sermon_found == 'true'
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          echo "Cleaning up transcript..."
          FILENAME="${{ steps.metadata.outputs.filename }}"
          python src/cleanup.py audio_sermon.json $GPT_MODEL "output/${FILENAME}.txt"

      - name: Update state
        if: steps.monitor.outputs.new_video == 'true'
        run: |
          VIDEO_ID="${{ steps.monitor.outputs.video_id }}"
          python -c "
          import json
          from datetime import datetime
          state = {'last_video_id': '${VIDEO_ID}', 'last_check': datetime.utcnow().isoformat()}
          with open('state.json', 'w') as f:
              json.dump(state, f, indent=2)
          "

      - name: Commit results
        if: steps.monitor.outputs.new_video == 'true' || steps.forced.outputs.new_video == 'true'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          VIDEO_ID="${{ steps.metadata.outputs.video_id }}"
          FILENAME="${{ steps.metadata.outputs.filename }}"
          SERMON_FOUND="${{ steps.segment.outputs.sermon_found }}"

          # Add the sermon transcript if it exists
          if [ "$SERMON_FOUND" == "true" ]; then
            git add "output/${FILENAME}.txt" || true
          fi
          git add state.json || true

          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            if [ "$SERMON_FOUND" == "true" ]; then
              git commit -m "Add sermon: ${FILENAME}"
            else
              git commit -m "Update state: no sermon found in video ${VIDEO_ID}"
            fi
            git push
          fi

      - name: Upload artifact
        if: (steps.monitor.outputs.new_video == 'true' || steps.forced.outputs.new_video == 'true') && steps.segment.outputs.sermon_found == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: sermon-transcript
          path: output/sermon_*.txt
          retention-days: 30
